<script>
(function(scope) {
var MoreRouting = scope.MoreRouting = scope.MoreRouting || {};
MoreRouting.Driver = Driver;

/**
 * TODO(nevir): Docs.
 */
function Driver(opt_config) {
  var config = opt_config || {};
  if (config.prefix) this.prefix = config.prefix;

  this._activeRoutes = [];

  this._rootRoutes = [];
}

Driver.prototype.manageRoute = function manageRoute(route) {
  route.driver = this;
  this._appendRoute(route);
  route.processPathParts(this.currentPathParts);
  if (route.active) this._activeRoutes.push(route);
};

Driver.prototype.urlForParts = function urlForParts(parts) {
  return this.prefix + parts.join(this.separator);
};

Driver.prototype.navigateToParts = function(parts) {
  return this.navigateToUrl(this.urlForParts(parts));
};

Driver.prototype.navigateToUrl = function navigateToUrl(url) {
  throw new Error(this.constructor.name + '#navigateToUrl not implemented');
};

// Subclass Interface

Driver.prototype.prefix = '/';
Driver.prototype.separator = '/';

Driver.prototype.setCurrentPath = function setCurrentPath(path) {
  this.currentPathParts = this.splitPath(path);
  var newRoutes = this._matchingRoutes(this.currentPathParts);

  // active -> inactive.
  for (var i = 0, route; route = this._activeRoutes[i]; i++) {
    if (newRoutes.indexOf(route) === -1) {
      route.processPathParts(null);
    }
  }

  this._activeRoutes = newRoutes;
}

Driver.prototype.splitPath = function splitPath(rawPath) {
  if (this.prefix && rawPath.indexOf(this.prefix) !== 0) {
    throw new Error(
        'Invalid path "' + rawPath + '"; ' +
        'expected it to be prefixed by "' + this.prefix + '"');
  }
  var path  = rawPath.substr(this.prefix.length);
  var parts = path.split(this.separator);
  // Ignore trailing separators.
  if (!parts[parts.length - 1]) parts.pop();

  return parts;
};

Driver.prototype.findParentPath = function findParentPath(rawPath, parentRoute, rootRoutes) {
  var compiled, candidates, route;
  compiled = MoreRouting.Route._compile(rawPath);
  candidates = [].concat(rootRoutes || this._rootRoutes);
  var compiledMatch = function compiledMatch(c1, c2) {
    return (c1.name ? c1.name === c2.name : c1.part === c2.part) && c1.type === c2.type;
  }
  route = candidates.shift();
  while (route != undefined) {
    for (var i = 0; i < route.compiled.length; i++) {
      if (!compiledMatch(route.compiled[i], compiled[i])) {
        break;
      } else if (i == route.compiled.length - 1) {
        // Find the parent by searching this path's children, short-circuiting if it's the last match.
        return this.findParentPath(rawPath.substring(route.path.length),
                                   route,
                                   route.children);
      }
    }
    route = candidates.shift();
  }
  return {
    parentRoute: parentRoute,
    fullPath: (parentRoute ? parentRoute.getFullPath() : '') + rawPath, 
    pathPart: rawPath
  };
}

// Internal Implementation
Driver.prototype._appendRoute = function _appendRoute(route) {
  if (route.parent) {
    // We only care about root routes.
    return;
  }
  this._rootRoutes.push(route);
};

Driver.prototype._matchingRoutes = function _matchingRoutes(parts, rootRoutes) {
  var route, routes, cadidates, tail;
  routes = [];
  candidates = [].concat(rootRoutes || this._rootRoutes);
  route = candidates.shift();
  while (route != undefined) {
    route.processPathParts(parts);
    if (route.active) {
      routes.push(route);
      tail = [].concat(parts);
      tail.splice(0,route.compiled.length);
      routes = routes.concat(this._matchingRoutes(tail, route.children));
      break;
    } else {
      route = candidates.shift();
    }
  }
  return routes;
}

})(window);
</script>
